<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Strip Animation Playground</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #61dafb;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
        }
        .animation-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .animation-preview {
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            width: 100%;
            max-width: 380px;
        }
        .led-strip-container {
            background-color: #121212;
            border-radius: 4px;
            padding: 5px;
            margin-bottom: 10px;
            overflow: auto;
            max-height: 500px;
        }
        .led-strip {
            display: flex;
            margin-bottom: 4px;
            height: 30px;
        }
        .led {
            width: 20px;
            height: 20px;
            margin: 0 2px;
            border-radius: 50%;
            background-color: #333;
            transition: background-color 0.2s;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .controls button {
            background-color: #61dafb;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .controls button:hover {
            background-color: #4fa8d1;
        }
        .editor-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        .animation-editor {
            flex: 1;
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            min-width: 300px;
        }
        textarea {
            width: 100%;
            height: 300px;
            background-color: #1e1e1e;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
        }
        .color-picker {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
        }
        .custom-animation {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        input, select {
            background-color: #333;
            color: #f0f0f0;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 4px;
        }
        label {
            margin-bottom: 5px;
            display: inline-block;
        }
        .bandwidth-calculator {
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        .bandwidth-results {
            background-color: #1e1e1e;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
        }
        .bandwidth-equation {
            font-family: monospace;
            background-color: #0d0d0d;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .info-box {
            background-color: #3a3a3a;
            border-left: 4px solid #61dafb;
            padding: 10px;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }
        .dimension-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .slider-container .slider-value {
            text-align: center;
            font-weight: bold;
        }
        .radio-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .radio-group label {
            margin-bottom: 0;
        }
        .tab-container {
            margin-top: 10px;
        }
        .tab-buttons {
            display: flex;
            gap: 5px;
        }
        .tab-button {
            background-color: #333;
            border: 1px solid #555;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            padding: 8px 15px;
            cursor: pointer;
        }
        .tab-button.active {
            background-color: #1e1e1e;
            border-bottom: 1px solid #1e1e1e;
            position: relative;
            top: 1px;
        }
        .tab-content {
            border: 1px solid #555;
            border-radius: 0 4px 4px 4px;
            padding: 15px;
            background-color: #1e1e1e;
        }
        .tip {
            font-style: italic;
            opacity: 0.8;
            font-size: 0.9em;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
        }
        .results-table th, .results-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .results-table th {
            color: #61dafb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LED Strip Animation Playground</h1>
        <p>Test, create, and save animations for a 60-LED strip. Preview animations side-by-side and export to JSON. Now supports 2D arrays!</p>
        
        <div class="animation-container" id="animation-container">
            <!-- Animation previews will be added here -->
        </div>
        
        <button id="add-animation" style="width: 200px; margin-bottom: 20px">+ Add Animation</button>
        
        <div class="editor-container">
            <div class="animation-editor">
                <h2>Animation Editor</h2>
                <div class="custom-animation">
                    <label for="animation-name">Animation Name:</label>
                    <input type="text" id="animation-name" placeholder="My Custom Animation">
                    
                    <label for="animation-type">Animation Type:</label>
                    <select id="animation-type">
                        <option value="chase">Chase</option>
                        <option value="pulse">Pulse</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="wipe">Color Wipe</option>
                        <option value="custom">Custom (JSON)</option>
                    </select>
                    
                    <div class="dimension-controls">
                        <div class="slider-container">
                            <label for="strip-length">Strip Length:</label>
                            <input type="range" id="strip-length" min="10" max="300" value="60" step="1">
                            <div class="slider-value" id="strip-length-value">60 LEDs</div>
                        </div>
                        
                        <div class="slider-container">
                            <label for="strip-height">Strip Height:</label>
                            <input type="range" id="strip-height" min="1" max="20" value="1" step="1">
                            <div class="slider-value" id="strip-height-value">1 Row</div>
                        </div>
                    </div>
                    
                    <div id="animation-params">
                        <label for="animation-speed">Speed (ms):</label>
                        <input type="number" id="animation-speed" value="100" min="10" max="2000">
                        
                        <label for="animation-direction">Direction:</label>
                        <select id="animation-direction">
                            <option value="forward">Forward</option>
                            <option value="backward">Backward</option>
                            <option value="bounce">Bounce</option>
                        </select>
                        
                        <div class="color-selection">
                            <label>Colors:</label>
                            <div class="color-picker" id="color-picker">
                                <div class="color-option" style="background-color: #ff0000" data-color="#ff0000"></div>
                                <div class="color-option" style="background-color: #00ff00" data-color="#00ff00"></div>
                                <div class="color-option" style="background-color: #0000ff" data-color="#0000ff"></div>
                                <div class="color-option" style="background-color: #ffff00" data-color="#ffff00"></div>
                                <div class="color-option" style="background-color: #ff00ff" data-color="#ff00ff"></div>
                                <div class="color-option" style="background-color: #00ffff" data-color="#00ffff"></div>
                                <div class="color-option" style="background-color: #ffffff" data-color="#ffffff"></div>
                                <input type="color" id="custom-color" value="#ff0000">
                            </div>
                            <div id="selected-colors"></div>
                        </div>
                    </div>
                    
                    <div id="custom-json-container" style="display: none;">
                        <label for="custom-json">Custom Animation JSON:</label>
                        <textarea id="custom-json" placeholder='{"frames": [{"leds": [{"index": 0, "color": "#ff0000"}, ...]}]}'></textarea>
                        <div class="tip">For 2D animations, use format: <code>{"frames": [{"leds": [{"x": 0, "y": 0, "color": "#ff0000"}, ...]}]}</code></div>
                    </div>
                    
                    <button id="apply-animation">Apply Animation</button>
                    <button id="save-animation">Save Animation</button>
                </div>
            </div>
            
            <div class="animation-editor">
                <h2>JSON Export</h2>
                <textarea id="json-export" readonly></textarea>
                <div class="controls">
                    <button id="copy-json">Copy JSON</button>
                    <button id="download-json">Download JSON</button>
                    <button id="load-json">Load JSON</button>
                    <input type="file" id="json-file-input" style="display: none" accept=".json">
                </div>
            </div>
        </div>
        
        <div class="bandwidth-calculator">
            <h2>Bandwidth Calculator</h2>
            <div class="info-box">
                <p>This calculator helps estimate the CAN bus bandwidth required for LED animations with real hardware.</p>
            </div>
            
            <div class="dimension-controls">
                <div class="slider-container">
                    <label for="bandwidth-fps">Target FPS:</label>
                    <input type="range" id="bandwidth-fps" min="1" max="60" value="30" step="1">
                    <div class="slider-value" id="bandwidth-fps-value">30 FPS</div>
                </div>
                
                <div class="slider-container">
                    <label for="differential-percentage">Changed LEDs (%):</label>
                    <input type="range" id="differential-percentage" min="1" max="100" value="30" step="1">
                    <div class="slider-value" id="differential-percentage-value">30%</div>
                </div>
                
                <div class="slider-container">
                    <label for="control-messages">Control Messages:</label>
                    <input type="range" id="control-messages" min="1" max="10" value="2" step="1">
                    <div class="slider-value" id="control-messages-value">2 msgs</div>
                </div>
            </div>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="equation">Bandwidth Equation</button>
                    <button class="tab-button" data-tab="calculator">Results</button>
                </div>
                <div class="tab-content">
                    <div id="equation-tab" class="tab-panel">
                        <div class="bandwidth-equation">
// Bandwidth calculation function
function calculateBandwidth(numLeds, fps, differentialPercentage, controlMessages = 2) {
  // CAN frame constants
  const BITS_PER_BYTE = 8;
  const CAN_OVERHEAD_BITS = 47;  // Standard CAN frame overhead
  const DATA_BYTES_PER_MESSAGE = 8;
  const USABLE_DATA_BYTES = 3;   // Bytes 5-7 in our protocol
  
  // Calculate bits per message
  const bitsPerMessage = (DATA_BYTES_PER_MESSAGE * BITS_PER_BYTE) + CAN_OVERHEAD_BITS;
  
  // Calculate messages needed for full frame updates
  const ledsPerMessage = USABLE_DATA_BYTES / 3;  // RGB bytes per LED
  const ledMessages = Math.ceil(numLeds / ledsPerMessage);
  
  // Total messages with control messages
  const messagesPerFullFrame = ledMessages + controlMessages;
  
  // Calculate differential messages (only changed LEDs)
  const changedLeds = Math.ceil(numLeds * (differentialPercentage / 100));
  const messagesPerDiffFrame = Math.ceil(changedLeds / ledsPerMessage) + controlMessages;
  
  // Calculate bits per second for full and differential updates
  const bpsFullFrame = messagesPerFullFrame * bitsPerMessage * fps;
  const bpsDiffFrame = messagesPerDiffFrame * bitsPerMessage * fps;
  
  // Calculate bandwidth percentages (based on 500 kbps CAN bus)
  const canBandwidth = 500000; // 500 kbps
  const percentBandwidthFull = (bpsFullFrame / canBandwidth) * 100;
  const percentBandwidthDiff = (bpsDiffFrame / canBandwidth) * 100;
  
  // Calculate max theoretical FPS
  const maxFpsFull = canBandwidth / (messagesPerFullFrame * bitsPerMessage);
  const maxFpsDiff = canBandwidth / (messagesPerDiffFrame * bitsPerMessage);
  
  return {
    messagesPerFullFrame,
    messagesPerDiffFrame,
    bitsPerFrame: messagesPerFullFrame * bitsPerMessage,
    bitsPerDiffFrame: messagesPerDiffFrame * bitsPerMessage,
    bpsFullFrame,
    bpsDiffFrame,
    percentBandwidthFull,
    percentBandwidthDiff,
    maxFpsFull,
    maxFpsDiff
  };
}
                        </div>
                    </div>
                    <div id="calculator-tab" class="tab-panel" style="display: none;">
                        <div class="bandwidth-results" id="bandwidth-results">
                            <h3>Bandwidth Requirements</h3>
                            <table class="results-table">
                                <tr>
                                    <th></th>
                                    <th>Full Updates</th>
                                    <th>Differential Updates</th>
                                </tr>
                                <tr>
                                    <td>Messages per frame:</td>
                                    <td id="msgs-full">-</td>
                                    <td id="msgs-diff">-</td>
                                </tr>
                                <tr>
                                    <td>Bits per frame:</td>
                                    <td id="bits-full">-</td>
                                    <td id="bits-diff">-</td>
                                </tr>
                                <tr>
                                    <td>Bits per second:</td>
                                    <td id="bps-full">-</td>
                                    <td id="bps-diff">-</td>
                                </tr>
                                <tr>
                                    <td>CAN bandwidth (%):</td>
                                    <td id="percent-full">-</td>
                                    <td id="percent-diff">-</td>
                                </tr>
                                <tr>
                                    <td>Max theoretical FPS:</td>
                                    <td id="max-fps-full">-</td>
                                    <td id="max-fps-diff">-</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // Initialize variables
    const NUM_LEDS = 60;
    let animations = [];
    let selectedColors = [];
    let animationPreviews = {};
    let is2DMode = false;

    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
        // Set up event listeners
        document.getElementById('add-animation').addEventListener('click', addNewAnimationPreview);
        document.getElementById('animation-type').addEventListener('change', toggleCustomJson);
        document.getElementById('apply-animation').addEventListener('click', applyAnimation);
        document.getElementById('save-animation').addEventListener('click', saveAnimation);
        document.getElementById('copy-json').addEventListener('click', copyJsonToClipboard);
        document.getElementById('download-json').addEventListener('click', downloadJson);
        document.getElementById('load-json').addEventListener('click', () => document.getElementById('json-file-input').click());
        document.getElementById('json-file-input').addEventListener('change', loadJsonFile);
        
        // Set up dimension controls
        document.getElementById('strip-length').addEventListener('input', updateDimensions);
        document.getElementById('strip-height').addEventListener('input', updateDimensions);
        
        // Set up bandwidth calculator
        document.getElementById('bandwidth-fps').addEventListener('input', updateBandwidthCalculator);
        document.getElementById('differential-percentage').addEventListener('input', updateBandwidthCalculator);
        document.getElementById('control-messages').addEventListener('input', updateBandwidthCalculator);
        
        // Set up tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', switchTab);
        });
        
        // Set up color picker
        const colorPicker = document.getElementById('color-picker');
        colorPicker.addEventListener('click', function(e) {
            if (e.target.classList.contains('color-option')) {
                addSelectedColor(e.target.dataset.color);
            }
        });
        
        document.getElementById('custom-color').addEventListener('change', function(e) {
            addSelectedColor(e.target.value);
        });
        
        // Add an initial animation preview
        addNewAnimationPreview();
        
        // Update JSON export
        updateJsonExport();
        
        // Initialize bandwidth calculator
        updateBandwidthCalculator();

        const jsonExportControls = document.querySelector('.animation-editor:nth-child(2) .controls');
        const pasteButton = document.createElement('button');
        pasteButton.id = 'paste-json';
        pasteButton.textContent = 'Import from Clipboard';
        jsonExportControls.insertBefore(pasteButton, document.getElementById('load-json'));
        pasteButton.addEventListener('click', importJsonFromClipboard);

        makeJsonBoxEditable();
    });

    function updateDimensions() {
        const length = parseInt(document.getElementById('strip-length').value);
        const height = parseInt(document.getElementById('strip-height').value);
        
        document.getElementById('strip-length-value').textContent = `${length} LEDs`;
        document.getElementById('strip-height-value').textContent = `${height} Row${height > 1 ? 's' : ''}`;
        
        is2DMode = height > 1;
        
        // Update bandwidth calculator
        updateBandwidthCalculator();
    }

    function switchTab(e) {
        const tabId = e.target.dataset.tab;
        
        // Update active tab button
        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.remove('active');
        });
        e.target.classList.add('active');
        
        // Show selected tab panel
        document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.style.display = 'none';
        });
        document.getElementById(`${tabId}-tab`).style.display = 'block';
    }

    function updateBandwidthCalculator() {
        const fps = parseInt(document.getElementById('bandwidth-fps').value);
        const diffPercentage = parseInt(document.getElementById('differential-percentage').value);
        const controlMsgs = parseInt(document.getElementById('control-messages').value);
        const length = parseInt(document.getElementById('strip-length').value);
        const height = parseInt(document.getElementById('strip-height').value);
        const totalLeds = length * height;
        
        // Update slider values
        document.getElementById('bandwidth-fps-value').textContent = `${fps} FPS`;
        document.getElementById('differential-percentage-value').textContent = `${diffPercentage}%`;
        document.getElementById('control-messages-value').textContent = `${controlMsgs} msg${controlMsgs > 1 ? 's' : ''}`;
        
        // Calculate bandwidth
        const results = calculateBandwidth(totalLeds, fps, diffPercentage, controlMsgs);
        
        // Update results table
        document.getElementById('msgs-full').textContent = results.messagesPerFullFrame;
        document.getElementById('msgs-diff').textContent = results.messagesPerDiffFrame;
        document.getElementById('bits-full').textContent = results.bitsPerFrame.toLocaleString();
        document.getElementById('bits-diff').textContent = results.bitsPerDiffFrame.toLocaleString();
        document.getElementById('bps-full').textContent = `${(results.bpsFullFrame / 1000).toFixed(2)} kbps`;
        document.getElementById('bps-diff').textContent = `${(results.bpsDiffFrame / 1000).toFixed(2)} kbps`;
        document.getElementById('percent-full').textContent = `${results.percentBandwidthFull.toFixed(2)}%`;
        document.getElementById('percent-diff').textContent = `${results.percentBandwidthDiff.toFixed(2)}%`;
        document.getElementById('max-fps-full').textContent = results.maxFpsFull.toFixed(1);
        document.getElementById('max-fps-diff').textContent = results.maxFpsDiff.toFixed(1);
    }

    // Bandwidth calculation function
function calculateBandwidth(numLeds, fps, differentialPercentage, controlMessages = 2) {
   // CAN frame constants
   const BITS_PER_BYTE = 8;
   const CAN_OVERHEAD_BITS = 47;  // Standard CAN frame overhead
   const DATA_BYTES_PER_MESSAGE = 8;
   const USABLE_DATA_BYTES = 3;   // Bytes 5-7 in our protocol
   
   // Calculate bits per message
   const bitsPerMessage = (DATA_BYTES_PER_MESSAGE * BITS_PER_BYTE) + CAN_OVERHEAD_BITS;
   
   // Calculate messages needed for full frame updates
   const ledsPerMessage = USABLE_DATA_BYTES / 3;  // RGB bytes per LED
   const ledMessages = Math.ceil(numLeds / ledsPerMessage);
   
   // Total messages with control messages
   const messagesPerFullFrame = ledMessages + controlMessages;
   
   // Calculate differential messages (only changed LEDs)
   const changedLeds = Math.ceil(numLeds * (differentialPercentage / 100));
   const messagesPerDiffFrame = Math.ceil(changedLeds / ledsPerMessage) + controlMessages;
   
   // Calculate bits per second for full and differential updates
   const bpsFullFrame = messagesPerFullFrame * bitsPerMessage * fps;
   const bpsDiffFrame = messagesPerDiffFrame * bitsPerMessage * fps;
   
   // Calculate bandwidth percentages (based on 500 kbps CAN bus)
   const canBandwidth = 500000; // 500 kbps
   const percentBandwidthFull = (bpsFullFrame / canBandwidth) * 100;
   const percentBandwidthDiff = (bpsDiffFrame / canBandwidth) * 100;
   
   // Calculate max theoretical FPS
   const maxFpsFull = canBandwidth / (messagesPerFullFrame * bitsPerMessage);
   const maxFpsDiff = canBandwidth / (messagesPerDiffFrame * bitsPerMessage);
   
   return {
       messagesPerFullFrame,
       messagesPerDiffFrame,
       bitsPerFrame: messagesPerFullFrame * bitsPerMessage,
       bitsPerDiffFrame: messagesPerDiffFrame * bitsPerMessage,
       bpsFullFrame,
       bpsDiffFrame,
       percentBandwidthFull,
       percentBandwidthDiff,
       maxFpsFull,
       maxFpsDiff
   };
}

function addNewAnimationPreview() {
   const container = document.getElementById('animation-container');
   const id = `animation-${Date.now()}`;
   const length = parseInt(document.getElementById('strip-length').value);
   const height = parseInt(document.getElementById('strip-height').value);
   
   const previewDiv = document.createElement('div');
   previewDiv.className = 'animation-preview';
   previewDiv.id = id;
   
   let stripHTML = '<div class="led-strip-container">';
   
   for (let y = 0; y < height; y++) {
       stripHTML += '<div class="led-strip">';
       for (let x = 0; x < length; x++) {
           stripHTML += '<div class="led"></div>';
       }
       stripHTML += '</div>';
   }
   
   stripHTML += '</div>';
   
   previewDiv.innerHTML = `
       <h3>Animation Preview</h3>
       ${stripHTML}
       <div class="controls">
           <button class="play-pause">Play</button>
           <button class="edit">Edit</button>
           <button class="remove">Remove</button>
       </div>
   `;
   
   container.appendChild(previewDiv);
   
   // Set up the LED strip with the default animation
   const animation = {
       name: `Animation ${container.children.length}`,
       type: 'chase',
       speed: 100,
       direction: 'forward',
       colors: ['#ff0000'],
       dimensions: {
           length: length,
           height: height
       },
       isPlaying: false,
       interval: null
   };
   
   animations.push(animation);
   animationPreviews[id] = animation;
   
   // Set up event listeners for this preview
   const playPauseBtn = previewDiv.querySelector('.play-pause');
   playPauseBtn.addEventListener('click', function() {
       if (animation.isPlaying) {
           stopAnimation(id);
           this.textContent = 'Play';
       } else {
           startAnimation(id);
           this.textContent = 'Pause';
       }
   });
   
   previewDiv.querySelector('.edit').addEventListener('click', function() {
       selectAnimationForEditing(id);
   });
   
   previewDiv.querySelector('.remove').addEventListener('click', function() {
       stopAnimation(id);
       previewDiv.remove();
       delete animationPreviews[id];
       animations = animations.filter(a => a !== animation);
       updateJsonExport();
   });
   
   // Start the animation
   startAnimation(id);
   
   // Update JSON export
   updateJsonExport();
}

function getAnimationElement(id, selector) {
  const elem = document.getElementById(id);
  if (!elem) return null;
  return selector ? elem.querySelector(selector) : elem;
}

function startAnimation(id) {
  const animation = animationPreviews[id];
  const container = getAnimationElement(id);
  
  if (!container) {
    console.error(`Animation container #${id} not found`);
    return;
  }
  
  const ledStripContainer = container.querySelector('.led-strip-container');
  if (!ledStripContainer) {
    console.error(`LED strip container in #${id} not found`);
    return;
  }
  
  const ledStrips = ledStripContainer.querySelectorAll('.led-strip');
  
  stopAnimation(id);
   
   let step = 0;
   let direction = 1;
   
   animation.isPlaying = true;
   
   animation.interval = setInterval(() => {
       // Clear all LEDs
       ledStrips.forEach(strip => {
           strip.querySelectorAll('.led').forEach(led => {
               led.style.backgroundColor = '#333';
           });
       });
       
       // Apply the animation based on type
       if (animation.dimensions.height === 1) {
           // 1D animations
           const leds = ledStrips[0].querySelectorAll('.led');
           
           switch (animation.type) {
               case 'chase':
                   const colorIndex = step % animation.colors.length;
                   const ledIndex = step % leds.length;
                   leds[ledIndex].style.backgroundColor = animation.colors[colorIndex];
                   break;
                   
               case 'pulse':
                   const pulseStep = step % 20;
                   const opacity = pulseStep < 10 ? pulseStep / 10 : (20 - pulseStep) / 10;
                   
                   leds.forEach((led, i) => {
                       const color = animation.colors[i % animation.colors.length];
                       const rgb = hexToRgb(color);
                       led.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                   });
                   break;
                   
               case 'rainbow':
                   leds.forEach((led, i) => {
                       const hue = ((i + step) % leds.length) * (360 / leds.length);
                       led.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                   });
                   break;
                   
               case 'wipe':
                   const colorWipeIndex = Math.floor(step / leds.length) % animation.colors.length;
                   const progress = step % leds.length;
                   
                   for (let i = 0; i <= progress; i++) {
                       leds[i].style.backgroundColor = animation.colors[colorWipeIndex];
                   }
                   break;
                   
               case 'custom':
                   if (animation.frames && animation.frames.length > 0) {
                       const frameIndex = step % animation.frames.length;
                       const frame = animation.frames[frameIndex];
                       
                       if (frame.leds) {
                           frame.leds.forEach(ledData => {
                               // Support both old and new format
                               if (ledData.hasOwnProperty('index')) {
                                   // Old format (1D)
                                   if (ledData.index >= 0 && ledData.index < leds.length) {
                                       leds[ledData.index].style.backgroundColor = ledData.color;
                                   }
                               } else if (ledData.hasOwnProperty('x') && ledData.hasOwnProperty('y')) {
                                   // New format (2D)
                                   if (ledData.y === 0 && ledData.x >= 0 && ledData.x < leds.length) {
                                       leds[ledData.x].style.backgroundColor = ledData.color;
                                   }
                               }
                           });
                       }
                   }
                   break;
           }
       } else {
           // 2D animations
           const totalLeds = animation.dimensions.length * animation.dimensions.height;
           
           switch (animation.type) {
               case 'chase':
                   const colorIndex = step % animation.colors.length;
                   const ledIndex = step % totalLeds;
                   const row = Math.floor(ledIndex / animation.dimensions.length);
                   const col = ledIndex % animation.dimensions.length;
                   
                   if (row < ledStrips.length) {
                       const leds = ledStrips[row].querySelectorAll('.led');
                       if (col < leds.length) {
                           leds[col].style.backgroundColor = animation.colors[colorIndex];
                       }
                   }
                   break;
                   
               case 'pulse':
                   const pulseStep = step % 20;
                   const opacity = pulseStep < 10 ? pulseStep / 10 : (20 - pulseStep) / 10;
                   
                   ledStrips.forEach((strip, y) => {
                       const leds = strip.querySelectorAll('.led');
                       leds.forEach((led, x) => {
                           const colorIndex = (y * animation.dimensions.length + x) % animation.colors.length;
                           const color = animation.colors[colorIndex];
                           const rgb = hexToRgb(color);
                           led.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                       });
                   });
                   break;
                   
               case 'rainbow':
                   ledStrips.forEach((strip, y) => {
                       const leds = strip.querySelectorAll('.led');
                       leds.forEach((led, x) => {
                           const index = y * animation.dimensions.length + x;
                           const hue = ((index + step) % totalLeds) * (360 / totalLeds);
                           led.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                       });
                   });
                   break;
                   
               case 'wipe':
                   const colorWipeIndex = Math.floor(step / totalLeds) % animation.colors.length;
                   const progress = step % totalLeds;
                   
                   for (let i = 0; i <= progress; i++) {
                       const row = Math.floor(i / animation.dimensions.length);
                       const col = i % animation.dimensions.length;
                       
                       if (row < ledStrips.length) {
                           const leds = ledStrips[row].querySelectorAll('.led');
                           if (col < leds.length) {
                               leds[col].style.backgroundColor = animation.colors[colorWipeIndex];
                           }
                       }
                   }
                   break;
                   
               case 'custom':
                   if (animation.frames && animation.frames.length > 0) {
                       const frameIndex = step % animation.frames.length;
                       const frame = animation.frames[frameIndex];
                       
                       if (frame.leds) {
                           frame.leds.forEach(ledData => {
                               // Support both formats
                               if (ledData.hasOwnProperty('index')) {
                                   // Convert 1D index to 2D
                                   const row = Math.floor(ledData.index / animation.dimensions.length);
                                   const col = ledData.index % animation.dimensions.length;
                                   
                                   if (row < ledStrips.length) {
                                       const leds = ledStrips[row].querySelectorAll('.led');
                                       if (col < leds.length) {
                                           leds[col].style.backgroundColor = ledData.color;
                                       }
                                   }
                               } else if (ledData.hasOwnProperty('x') && ledData.hasOwnProperty('y')) {
                                   // Direct 2D access
                                   if (ledData.y < ledStrips.length) {
                                       const leds = ledStrips[ledData.y].querySelectorAll('.led');
                                       if (ledData.x < leds.length) {
                                           leds[ledData.x].style.backgroundColor = ledData.color;
                                       }
                                   }
                               }
                           });
                       }
                   }
                   break;
           }
       }
       
       // Update step based on direction
       if (animation.direction === 'forward') {
           step++;
       } else if (animation.direction === 'backward') {
           step = (step - 1 + totalLeds) % totalLeds;
       } else if (animation.direction === 'bounce') {
           step += direction;
           if (step >= totalLeds - 1 || step <= 0) {
               direction *= -1;
           }
       }
   }, animation.speed);
}

function stopAnimation(id) {
   const animation = animationPreviews[id];
   if (animation.interval) {
       clearInterval(animation.interval);
       animation.interval = null;
       animation.isPlaying = false;
   }
}

function selectAnimationForEditing(id) {
    const animation = animationPreviews[id];
    
    document.getElementById('animation-name').value = animation.name;
    document.getElementById('animation-type').value = animation.type;
    document.getElementById('animation-speed').value = animation.speed;
    document.getElementById('animation-direction').value = animation.direction;
    
    // Set dimensions
    document.getElementById('strip-length').value = animation.dimensions.length;
    document.getElementById('strip-height').value = animation.dimensions.height;
    document.getElementById('strip-length-value').textContent = `${animation.dimensions.length} LEDs`;
    document.getElementById('strip-height-value').textContent = `${animation.dimensions.height} Row${animation.dimensions.height > 1 ? 's' : ''}`;
    
    // Clear selected colors
    selectedColors = [...animation.colors];
    updateSelectedColors();
    
    toggleCustomJson();
    
    if (animation.type === 'custom' && animation.frames) {
        document.getElementById('custom-json').value = JSON.stringify({frames: animation.frames}, null, 2);
    }
    
    // Store the ID of the animation being edited
    document.getElementById('apply-animation').dataset.editingId = id;
}

function toggleCustomJson() {
    const animationType = document.getElementById('animation-type').value;
    const customJsonContainer = document.getElementById('custom-json-container');
    const animationParams = document.getElementById('animation-params');
    
    if (animationType === 'custom') {
        customJsonContainer.style.display = 'block';
        animationParams.style.display = 'none';
    } else {
        customJsonContainer.style.display = 'none';
        animationParams.style.display = 'block';
    }
}

function applyAnimation() {
    const id = document.getElementById('apply-animation').dataset.editingId;
    if (!id || !animationPreviews[id]) return;
    
    const animation = animationPreviews[id];
    const name = document.getElementById('animation-name').value;
    const type = document.getElementById('animation-type').value;
    const speed = parseInt(document.getElementById('animation-speed').value);
    const direction = document.getElementById('animation-direction').value;
    const length = parseInt(document.getElementById('strip-length').value);
    const height = parseInt(document.getElementById('strip-height').value);
    
    // Recreate the preview if dimensions changed
    if (animation.dimensions.length !== length || animation.dimensions.height !== height) {
        const previewDiv = document.getElementById(id);
        let stripHTML = '<div class="led-strip-container">';
        
        for (let y = 0; y < height; y++) {
            stripHTML += '<div class="led-strip">';
            for (let x = 0; x < length; x++) {
                stripHTML += '<div class="led"></div>';
            }
            stripHTML += '</div>';
        }
        
        stripHTML += '</div>';
        
        // Replace just the LED strip container
        previewDiv.querySelector('.led-strip-container').outerHTML = stripHTML;
    }
    
    animation.name = name;
    animation.type = type;
    animation.speed = speed;
    animation.direction = direction;
    animation.dimensions = { length, height };
    
    if (type === 'custom') {
        try {
            const customJson = JSON.parse(document.getElementById('custom-json').value);
            
            // Ensure the customJson includes 'frames' property
            if (!customJson.hasOwnProperty('frames')) {
                throw new Error('JSON must include a "frames" property.');
            }
            
            animation.frames = customJson.frames;
            
            // If in 2D mode, attempt to convert 1D indices to 2D coordinates
            if (height > 1) {
                animation.frames.forEach(frame => {
                    if (frame.leds) {
                        frame.leds.forEach(ledData => {
                            // Convert 1D indices to 2D if needed
                            if (ledData.hasOwnProperty('index') && !ledData.hasOwnProperty('x') && !ledData.hasOwnProperty('y')) {
                                const index = ledData.index;
                                const x = index % length;
                                const y = Math.floor(index / length);
                                
                                // Keep backward compatibility
                                ledData.x = x;
                                ledData.y = y;
                                // We keep the index property for backward compatibility
                            }
                        });
                    }
                });
            }
        } catch (error) {
            alert('Invalid JSON format: ' + error.message);
            return;
        }
    } else {
        animation.colors = [...selectedColors];
    }
    
    // Restart the animation
    stopAnimation(id);
    startAnimation(id);
    
    // Update the header
    const header = document.querySelector(`#${id} h3`);
    header.textContent = animation.name;
    
    // Update JSON export
    updateJsonExport();
    
    // Update bandwidth calculator
    updateBandwidthCalculator();
}

function saveAnimation() {
    // Create a new animation with the current settings
    const name = document.getElementById('animation-name').value;
    const type = document.getElementById('animation-type').value;
    const speed = parseInt(document.getElementById('animation-speed').value);
    const direction = document.getElementById('animation-direction').value;
    const length = parseInt(document.getElementById('strip-length').value);
    const height = parseInt(document.getElementById('strip-height').value);
    
    const animation = {
        name: name,
        type: type,
        speed: speed,
        direction: direction,
        dimensions: {
            length: length,
            height: height
        },
        colors: [...selectedColors],
        isPlaying: false,
        interval: null
    };
    
    if (type === 'custom') {
        try {
            const customJson = JSON.parse(document.getElementById('custom-json').value);
            
            // Ensure the customJson includes 'frames' property
            if (!customJson.hasOwnProperty('frames')) {
                throw new Error('JSON must include a "frames" property.');
            }
            
            animation.frames = customJson.frames;
            
            // If in 2D mode, attempt to convert 1D indices to 2D coordinates
            if (height > 1) {
                animation.frames.forEach(frame => {
                    if (frame.leds) {
                        frame.leds.forEach(ledData => {
                            // Convert 1D indices to 2D if needed
                            if (ledData.hasOwnProperty('index') && !ledData.hasOwnProperty('x') && !ledData.hasOwnProperty('y')) {
                                const index = ledData.index;
                                const x = index % length;
                                const y = Math.floor(index / length);
                                
                                // Keep backward compatibility
                                ledData.x = x;
                                ledData.y = y;
                                // We keep the index property for backward compatibility
                            }
                        });
                    }
                });
            }
        } catch (error) {
            alert('Invalid JSON format: ' + error.message);
            return;
        }
    }
    
    // Add as a new animation preview
    const container = document.getElementById('animation-container');
    const id = `animation-${Date.now()}`;
    
    const previewDiv = document.createElement('div');
    previewDiv.className = 'animation-preview';
    previewDiv.id = id;
    
    let stripHTML = '<div class="led-strip-container">';
    
    for (let y = 0; y < height; y++) {
        stripHTML += '<div class="led-strip">';
        for (let x = 0; x < length; x++) {
            stripHTML += '<div class="led"></div>';
        }
        stripHTML += '</div>';
    }
    
    stripHTML += '</div>';
    
    previewDiv.innerHTML = `
        <h3>${animation.name}</h3>
        ${stripHTML}
        <div class="controls">
            <button class="play-pause">Pause</button>
            <button class="edit">Edit</button>
            <button class="remove">Remove</button>
        </div>
    `;
    
    container.appendChild(previewDiv);
    
    animations.push(animation);
    animationPreviews[id] = animation;
    
    // Set up event listeners
    const playPauseBtn = previewDiv.querySelector('.play-pause');
    playPauseBtn.addEventListener('click', function() {
        if (animation.isPlaying) {
            stopAnimation(id);
            this.textContent = 'Play';
        } else {
            startAnimation(id);
            this.textContent = 'Pause';
        }
    });
    
    previewDiv.querySelector('.edit').addEventListener('click', function() {
        selectAnimationForEditing(id);
    });
    
    previewDiv.querySelector('.remove').addEventListener('click', function() {
        stopAnimation(id);
        previewDiv.remove();
        delete animationPreviews[id];
        animations = animations.filter(a => a !== animation);
        updateJsonExport();
    });
    
    // Start the animation
    startAnimation(id);
    
    // Update JSON export
    updateJsonExport();
    
    // Update bandwidth calculator
    updateBandwidthCalculator();
}

function addSelectedColor(color) {
    selectedColors.push(color);
    updateSelectedColors();
}

function updateSelectedColors() {
    const container = document.getElementById('selected-colors');
    container.innerHTML = '';
    
    selectedColors.forEach((color, index) => {
        const colorDiv = document.createElement('div');
        colorDiv.style.display = 'inline-block';
        colorDiv.style.marginRight = '10px';
        colorDiv.style.marginBottom = '10px';
        
        const colorSwatch = document.createElement('div');
        colorSwatch.style.width = '30px';
        colorSwatch.style.height = '30px';
        colorSwatch.style.backgroundColor = color;
        colorSwatch.style.display = 'inline-block';
        colorSwatch.style.borderRadius = '4px';
        colorSwatch.style.marginRight = '5px';
        
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'x';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.backgroundColor = '#ff4444';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.borderRadius = '50%';
        removeBtn.style.width = '20px';
        removeBtn.style.height = '20px';
        removeBtn.style.fontSize = '12px';
        removeBtn.style.lineHeight = '1';
        removeBtn.style.padding = '0';
        
        removeBtn.addEventListener('click', function() {
            selectedColors.splice(index, 1);
            updateSelectedColors();
        });
        
        colorDiv.appendChild(colorSwatch);
        colorDiv.appendChild(removeBtn);
        container.appendChild(colorDiv);
    });
    
    if (selectedColors.length === 0) {
        container.innerHTML = '<em>No colors selected</em>';
    }
}

function updateJsonExport() {
    const exportData = {
        animations: animations.map(a => {
            const exportAnimation = {
                name: a.name,
                type: a.type,
                speed: a.speed,
                direction: a.direction,
                dimensions: a.dimensions
            };
            
            if (a.type === 'custom') {
                exportAnimation.frames = a.frames;
            } else {
                exportAnimation.colors = a.colors;
            }
            
            return exportAnimation;
        })
    };
    
    document.getElementById('json-export').value = JSON.stringify(exportData, null, 2);
}

function copyJsonToClipboard() {
    const jsonText = document.getElementById('json-export');
    jsonText.select();
    document.execCommand('copy');
    alert('JSON copied to clipboard');
}

function downloadJson() {
    const jsonStr = document.getElementById('json-export').value;
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonStr);
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "led-animations.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

// Add this to your HTML inside the JSON Export editor section
function addPasteImportButton() {
  const jsonExportControls = document.querySelector('.animation-editor:nth-child(2) .controls');
  
  // Create new button
  const pasteButton = document.createElement('button');
  pasteButton.id = 'paste-json';
  pasteButton.textContent = 'Import from Clipboard';
  
  // Insert before the Load JSON button
  const loadButton = document.getElementById('load-json');
  jsonExportControls.insertBefore(pasteButton, loadButton);
  
  // Add event listener
  pasteButton.addEventListener('click', importJsonFromClipboard);
}

// Function to import JSON from clipboard
function importJsonFromClipboard() {
  // Get the textarea content
  const jsonText = document.getElementById('json-export').value;
  
  if (!jsonText.trim()) {
    alert('Please paste JSON into the export field first');
    return;
  }
  
  try {
    const data = JSON.parse(jsonText);
    loadAnimationsFromData(data);
  } catch (error) {
    console.error('JSON parse error:', error);
    alert('Error parsing JSON: ' + error.message);
  }
}

// Shared function to load animations (used by both file import and clipboard import)
// Use this improved function to safely load animations 
function loadAnimationsFromData(data) {
  console.log('Starting animation loading process');
  
  if (!data || !data.animations || !Array.isArray(data.animations)) {
    console.error('Invalid JSON structure:', data);
    alert('Invalid animation JSON format - "animations" array not found');
    return;
  }
  
  // Clear existing animations
  console.log('Clearing existing animations');
  for (const id in animationPreviews) {
    stopAnimation(id);
    const elem = document.getElementById(id);
    if (elem) elem.remove();
  }
  
  animationPreviews = {};
  animations = [];
  
  console.log(`Loading ${data.animations.length} animations`);
  
  // Add imported animations one by one
  data.animations.forEach((a, index) => {
    createAnimationPreview(a, index);
  });
  
  console.log('Updating JSON export and bandwidth calculator');
  updateJsonExport();
  updateBandwidthCalculator();
}

// Function to create a single animation preview
function createAnimationPreview(animData, index) {
  const container = document.getElementById('animation-container');
  const id = `anim-${index}`;
  
  console.log(`Creating animation ${id}: ${animData.name}`);
  
  // Handle legacy data format (without dimensions)
  if (!animData.dimensions) {
    animData.dimensions = {
      length: 60,
      height: 1
    };
  }
  
  const length = animData.dimensions.length;
  const height = animData.dimensions.height;
  
  const previewDiv = document.createElement('div');
  previewDiv.className = 'animation-preview';
  previewDiv.id = id;
  
  // Create LED strip HTML
  let stripHTML = '<div class="led-strip-container">';
  for (let y = 0; y < height; y++) {
    stripHTML += '<div class="led-strip">';
    for (let x = 0; x < length; x++) {
      stripHTML += '<div class="led"></div>';
    }
    stripHTML += '</div>';
  }
  stripHTML += '</div>';
  
  previewDiv.innerHTML = `
    <h3>${animData.name}</h3>
    ${stripHTML}
    <div class="controls">
      <button class="play-pause">Play</button>
      <button class="edit">Edit</button>
      <button class="remove">Remove</button>
    </div>
  `;
  
  container.appendChild(previewDiv);
  
  // Create animation object
  const animation = {
    name: animData.name,
    type: animData.type || 'chase',
    speed: animData.speed || 100,
    direction: animData.direction || 'forward',
    dimensions: animData.dimensions,
    colors: animData.colors || ['#ff0000'],
    frames: animData.frames,
    isPlaying: false,
    interval: null
  };
  
  // Add to animation collections
  animations.push(animation);
  animationPreviews[id] = animation;
  
  // Set up event listeners
  setupAnimationControls(id, animation);
  
  // Start the animation
  startAnimation(id);
}

// Set up controls for an animation
function setupAnimationControls(id, animation) {
  const previewDiv = document.getElementById(id);
  if (!previewDiv) {
    console.error(`Preview div #${id} not found`);
    return;
  }
  
  const playPauseBtn = previewDiv.querySelector('.play-pause');
  playPauseBtn.addEventListener('click', function() {
    if (animation.isPlaying) {
      stopAnimation(id);
      this.textContent = 'Play';
    } else {
      startAnimation(id);
      this.textContent = 'Pause';
    }
  });
  
  previewDiv.querySelector('.edit').addEventListener('click', function() {
    selectAnimationForEditing(id);
  });
  
  previewDiv.querySelector('.remove').addEventListener('click', function() {
    stopAnimation(id);
    previewDiv.remove();
    delete animationPreviews[id];
    animations = animations.filter(a => a !== animation);
    updateJsonExport();
  });
}

// Function to import JSON from clipboard
function importJsonFromClipboard() {
  // Get the textarea content
  const jsonText = document.getElementById('json-export').value;
  
  if (!jsonText.trim()) {
    alert('Please paste JSON into the export field first');
    return;
  }
  
  try {
    console.log('Parsing JSON from clipboard');
    const data = JSON.parse(jsonText);
    console.log('JSON parsed successfully, loading animations');
    loadAnimationsFromData(data);
  } catch (error) {
    console.error('JSON parse error:', error);
    alert('Error parsing JSON: ' + error.message);
  }
}

// Modify loadJsonFile to use the shared function
function loadJsonFile(event) {
  const file = event.target.files[0];
  if (!file) {
    console.log('No file selected');
    return;
  }
  
  console.log('Loading file:', file.name);
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      console.log('File loaded, parsing JSON');
      const data = JSON.parse(e.target.result);
      console.log('JSON parsed:', data);
      loadAnimationsFromData(data);
    } catch (error) {
      console.error('JSON parse error:', error);
      alert('Error loading JSON file: ' + error.message);
    }
  };
  
  reader.onerror = function(e) {
    console.error('FileReader error:', e);
    alert('Error reading file');
  };
  
  reader.readAsText(file);
}

// Make JSON box editable and add direct apply button
function makeJsonBoxEditable() {
  const jsonExport = document.getElementById('json-export');
  jsonExport.readOnly = false;
  
  // Add button to apply JSON directly
  const directLoadBtn = document.createElement('button');
  directLoadBtn.id = 'apply-json';
  directLoadBtn.textContent = 'Apply This JSON';
  directLoadBtn.style.backgroundColor = '#ff9800';
  
  directLoadBtn.addEventListener('click', function() {
    try {
      const jsonText = jsonExport.value;
      const data = JSON.parse(jsonText);
      
      if (!data.animations || !Array.isArray(data.animations)) {
        throw new Error("Invalid format - missing animations array");
      }
      
      // Clear existing animations
      const container = document.getElementById('animation-container');
      container.innerHTML = '';
      animationPreviews = {};
      animations = [];
      
      // Create each animation preview
      data.animations.forEach(animData => {
        const id = `animation-${Date.now()}-${Math.random().toString().substring(2, 8)}`;
        createNewAnimationFromData(id, animData);
      });
      
      alert('Animations applied successfully!');
    } catch (error) {
      alert('Error: ' + error.message);
    }
  });
  
  const controls = document.querySelector('.animation-editor:nth-child(2) .controls');
  controls.insertBefore(directLoadBtn, controls.firstChild);
}

// Function to create animation from data
function createNewAnimationFromData(id, animData) {
  // Set defaults for missing properties
  const dims = animData.dimensions || { length: 60, height: 1 };
  const length = dims.length || 60;
  const height = dims.height || 1;
  
  // Create the HTML
  const container = document.getElementById('animation-container');
  const previewDiv = document.createElement('div');
  previewDiv.className = 'animation-preview';
  previewDiv.id = id;
  
  let stripHTML = '<div class="led-strip-container">';
  for (let y = 0; y < height; y++) {
    stripHTML += '<div class="led-strip">';
    for (let x = 0; x < length; x++) {
      stripHTML += '<div class="led"></div>';
    }
    stripHTML += '</div>';
  }
  stripHTML += '</div>';
  
  previewDiv.innerHTML = `
    <h3>${animData.name || "Unnamed Animation"}</h3>
    ${stripHTML}
    <div class="controls">
      <button class="play-pause">Play</button>
      <button class="edit">Edit</button>
      <button class="remove">Remove</button>
    </div>
  `;
  
  container.appendChild(previewDiv);
  
  // Create animation object
  const animation = {
    name: animData.name || "Unnamed Animation",
    type: animData.type || 'chase',
    speed: animData.speed || 100,
    direction: animData.direction || 'forward',
    dimensions: dims,
    colors: animData.colors || ['#ff0000'],
    frames: animData.frames || [],
    isPlaying: false,
    interval: null
  };
  
  // Store animation
  animations.push(animation);
  animationPreviews[id] = animation;
  
  // Set up event listeners
  const playPauseBtn = previewDiv.querySelector('.play-pause');
  playPauseBtn.addEventListener('click', function() {
    if (animation.isPlaying) {
      stopAnimation(id);
      this.textContent = 'Play';
    } else {
      startAnimation(id);
      this.textContent = 'Pause';
    }
  });
  
  previewDiv.querySelector('.edit').addEventListener('click', function() {
    selectAnimationForEditing(id);
  });
  
  previewDiv.querySelector('.remove').addEventListener('click', function() {
    stopAnimation(id);
    previewDiv.remove();
    delete animationPreviews[id];
    animations = animations.filter(a => a !== animation);
    updateJsonExport();
  });
  
  // Start the animation
  startAnimation(id);
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : {r: 0, g: 0, b: 0};
}

// --- Functions for Parent Communication ---

// Function to get current frame data as RGB array
function getCurrentFrameRGBData() {
    const ledData = [];
    const ledElements = document.querySelectorAll('.animation-preview .led-strip .led'); // Assuming only one preview for simplicity now
    ledElements.forEach(led => {
        const bgColor = led.style.backgroundColor;
        if (bgColor && bgColor.startsWith('rgb')) {
            const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                ledData.push([parseInt(match[1]), parseInt(match[2]), parseInt(match[3])]);
            } else {
                ledData.push([0, 0, 0]); // Default if parsing fails
            }
        } else {
             // Try converting hex if needed, or default to black
             if (bgColor && bgColor.startsWith('#')) {
                 const rgb = hexToRgb(bgColor);
                 ledData.push([rgb.r, rgb.g, rgb.b]);
             } else {
                ledData.push([0, 0, 0]); // Default to black if no valid color
             }
        }
    });
    // Ensure the array has the correct number of LEDs based on current settings
    const length = parseInt(document.getElementById('strip-length').value);
    const height = parseInt(document.getElementById('strip-height').value);
    const totalLeds = length * height;
    while (ledData.length < totalLeds) {
        ledData.push([0, 0, 0]);
    }
    return ledData.slice(0, totalLeds); // Return exactly the expected number
}

// Function to notify parent window of frame update
function notifyParentFrameUpdate() {
    // Check if running inside an iframe before posting
    if (window.self !== window.top) {
         console.log("Animator: Notifying parent of frame update");
         // Use specific origin for better security
         window.parent.postMessage({ type: 'animatorFrameUpdate' }, window.location.origin);
    } else {
         console.log("Animator: Not running in iframe, skipping parent notification.");
    }
}

// --- Modify existing functions to notify parent ---

// Modify startAnimation interval to notify parent after updating preview
function startAnimation(id) {
  const animation = animationPreviews[id];
  const container = getAnimationElement(id);

  if (!container) {
    console.error(`Animation container #${id} not found`);
    return;
  }

  const ledStripContainer = container.querySelector('.led-strip-container');
  if (!ledStripContainer) {
    console.error(`LED strip container in #${id} not found`);
    return;
  }

  const ledStrips = ledStripContainer.querySelectorAll('.led-strip');

  stopAnimation(id);

   let step = 0;
   let direction = 1;

   animation.isPlaying = true;

   animation.interval = setInterval(() => {
       // ... (existing animation logic to update visuals) ...

       // Apply the animation based on type
       const totalLeds = animation.dimensions.length * animation.dimensions.height; // Calculate total LEDs
       if (animation.dimensions.height === 1) {
           // 1D animations
           const leds = ledStrips[0].querySelectorAll('.led');
            // Clear all LEDs first
           leds.forEach(led => { led.style.backgroundColor = '#333'; });

           switch (animation.type) {
               // ... (cases for chase, pulse, rainbow, wipe, custom 1D) ...
                case 'chase':
                   const colorIndex = step % animation.colors.length;
                   const ledIndex = step % leds.length;
                   leds[ledIndex].style.backgroundColor = animation.colors[colorIndex];
                   break;
               case 'pulse':
                   const pulseStep = step % 20;
                   const opacity = pulseStep < 10 ? pulseStep / 10 : (20 - pulseStep) / 10;
                   leds.forEach((led, i) => {
                       const color = animation.colors[i % animation.colors.length];
                       const rgb = hexToRgb(color);
                       led.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                   });
                   break;
               case 'rainbow':
                   leds.forEach((led, i) => {
                       const hue = ((i + step) % leds.length) * (360 / leds.length);
                       led.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                   });
                   break;
               case 'wipe':
                   const colorWipeIndex = Math.floor(step / leds.length) % animation.colors.length;
                   const progress = step % leds.length;
                   for (let i = 0; i <= progress; i++) {
                       leds[i].style.backgroundColor = animation.colors[colorWipeIndex];
                   }
                   break;
               case 'custom':
                   if (animation.frames && animation.frames.length > 0) {
                       const frameIndex = step % animation.frames.length;
                       const frame = animation.frames[frameIndex];
                       if (frame.leds) {
                           frame.leds.forEach(ledData => {
                               if (ledData.hasOwnProperty('index')) {
                                   if (ledData.index >= 0 && ledData.index < leds.length) {
                                       leds[ledData.index].style.backgroundColor = ledData.color;
                                   }
                               } else if (ledData.hasOwnProperty('x') && ledData.hasOwnProperty('y')) {
                                   if (ledData.y === 0 && ledData.x >= 0 && ledData.x < leds.length) {
                                       leds[ledData.x].style.backgroundColor = ledData.color;
                                   }
                               }
                           });
                       }
                   }
                   break;
           }
       } else {
           // 2D animations
            // Clear all LEDs first
           ledStrips.forEach(strip => { strip.querySelectorAll('.led').forEach(led => { led.style.backgroundColor = '#333'; }); });

           switch (animation.type) {
                // ... (cases for chase, pulse, rainbow, wipe, custom 2D) ...
                case 'chase':
                   const colorIndex = step % animation.colors.length;
                   const ledIndex = step % totalLeds;
                   const row = Math.floor(ledIndex / animation.dimensions.length);
                   const col = ledIndex % animation.dimensions.length;
                   if (row < ledStrips.length) {
                       const leds = ledStrips[row].querySelectorAll('.led');
                       if (col < leds.length) { leds[col].style.backgroundColor = animation.colors[colorIndex]; }
                   }
                   break;
               case 'pulse':
                   const pulseStep = step % 20;
                   const opacity = pulseStep < 10 ? pulseStep / 10 : (20 - pulseStep) / 10;
                   ledStrips.forEach((strip, y) => {
                       const leds = strip.querySelectorAll('.led');
                       leds.forEach((led, x) => {
                           const colorIndex = (y * animation.dimensions.length + x) % animation.colors.length;
                           const color = animation.colors[colorIndex];
                           const rgb = hexToRgb(color);
                           led.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                       });
                   });
                   break;
               case 'rainbow':
                   ledStrips.forEach((strip, y) => {
                       const leds = strip.querySelectorAll('.led');
                       leds.forEach((led, x) => {
                           const index = y * animation.dimensions.length + x;
                           const hue = ((index + step) % totalLeds) * (360 / totalLeds);
                           led.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                       });
                   });
                   break;
               case 'wipe':
                   const colorWipeIndex = Math.floor(step / totalLeds) % animation.colors.length;
                   const progress = step % totalLeds;
                   for (let i = 0; i <= progress; i++) {
                       const row = Math.floor(i / animation.dimensions.length);
                       const col = i % animation.dimensions.length;
                       if (row < ledStrips.length) {
                           const leds = ledStrips[row].querySelectorAll('.led');
                           if (col < leds.length) { leds[col].style.backgroundColor = animation.colors[colorWipeIndex]; }
                       }
                   }
                   break;
               case 'custom':
                   if (animation.frames && animation.frames.length > 0) {
                       const frameIndex = step % animation.frames.length;
                       const frame = animation.frames[frameIndex];
                       if (frame.leds) {
                           frame.leds.forEach(ledData => {
                               if (ledData.hasOwnProperty('index')) {
                                   const row = Math.floor(ledData.index / animation.dimensions.length);
                                   const col = ledData.index % animation.dimensions.length;
                                   if (row < ledStrips.length) {
                                       const leds = ledStrips[row].querySelectorAll('.led');
                                       if (col < leds.length) { leds[col].style.backgroundColor = ledData.color; }
                                   }
                               } else if (ledData.hasOwnProperty('x') && ledData.hasOwnProperty('y')) {
                                   if (ledData.y < ledStrips.length) {
                                       const leds = ledStrips[ledData.y].querySelectorAll('.led');
                                       if (ledData.x < leds.length) { leds[ledData.x].style.backgroundColor = ledData.color; }
                                   }
                               }
                           });
                       }
                   }
                   break;
           }
       }

       // Update step based on direction
       if (animation.direction === 'forward') {
           step++;
       } else if (animation.direction === 'backward') {
           // Ensure step wraps around correctly for totalLeds
           step = (step - 1 + totalLeds) % totalLeds;
       } else if (animation.direction === 'bounce') {
           step += direction;
           if (step >= totalLeds - 1 || step <= 0) {
               direction *= -1;
           }
       }

       // Notify parent after updating visuals
       notifyParentFrameUpdate();

   }, animation.speed);
}


// Modify applyAnimation to notify parent
function applyAnimation() {
    // ... (existing applyAnimation logic) ...

    // Restart the animation (which updates the preview)
    stopAnimation(id);
    startAnimation(id);

    // Update the header
    const header = document.querySelector(`#${id} h3`);
    header.textContent = animation.name;

    // Update JSON export
    updateJsonExport();

    // Update bandwidth calculator
    updateBandwidthCalculator();

    // Notify parent after applying changes
    notifyParentFrameUpdate();
}


    </script>
</body>
</html>
